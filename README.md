# TrustMessage-可靠消息中心
# 什么是可靠消息

消息队列中有一个非常重要的概念是消息丢失，与之相对的概念就是可靠消息，即消息不丢失。 以下提到消息不丢失或者可靠消息时，均是指同一个概念。

消息队列的实现一般都分为3个角色，以kafka 为例
1. 生产者
2. broker
3. 消费者

如果仅从和消息队列交互的角度来讲，消息不丢失可以分别从这3个角度考虑
1. 生产者 ack + ISR
2. broker 刷盘机制
3. 消费者  消费提交commit

broker  对于业务开来说,除了合理的刷盘参数配置做不了其他事，当然也不需要做其他事。

消费者 也几乎不需要额外做什么，除非你使用了异步消费机制。 因此以下主要讨从生产者的角度看如何消息不丢失，即可靠消息。

## 从业务的角度理解可靠消息-事务消息

如果把消息发送和业务逻辑结合起来，可以这样理解，发送者在完成业务之后，一定要把消息发送出去， 相当于是业务操作+消息发送应该是一个事务操作，要不都成功，要么都失败。

# 消息队列里的事务是什么
当我们谈论事务时，一般我们都说是一批操作的集合，要么全部成功要么全部失败，满足ACID 特性。

所以当我们谈论与消息队列有关的事务时，也应该是一批操作的集合。那么在消息队列里，指的是消息的什么操作集合呢。

如前所说消息队列的实现一般都分为3个角色，也就对应3种操作，消息生产、消费、broker。

从client的视角来看，有生产事务、消费事务、生产 + 消费事务、消费 + 处理 + 生产，以及今天会重点讨论的业务操作+生产事务 。

从业界来看，不同消息队列实现的是满足不同场景的事务，不同事务的具体技术实现也是不一样的。

# 主流消息队列的事务功能
## RabbitMQ 的事务消息
RabbitMQ 支持的事务满足的是生产消息的事务。即一批生产操作要么全部成功，要么全部失败。RabbitMQ 的事务是在 Channel 维度实现的。将通道（Channel）设置为事务模式后，所有发送到该通道的消息都将被缓存下来。事务提交后，这些消息才会被投递到具体的 Exchange 中。如果事务提交失败，可以进行事务回滚，使消息不会被发送到目标 Exchange。

## Kafka 的事务消息
Kafka 支持的事务跟 RabbitMQ 一样，满足的也是生产消息的事务。即保证一批生产操作要么全部成功，要么全部失败。和 RabbitMQ 事务不同的是，Kafka 的事务是在事务 ID 维度生效的。
### Kafka生产事务消息

Kafka从0.11版本开始引入了事务API，允许生产者在单个或多个分区中原子地写入消息(Kafka的事务消息功能是为了支持跨多个分区和主题的原子写入操作)。这意味着你可以确保一组消息要么全部被提交，要么全部不提交，从而实现事务的概念。

1. **开启事务支持：** 为了使用事务，你需要在生产者配置中设置`transactional.id`属性。这个属性标识了事务的唯一性，Kafka使用它来恢复事务状态。与每次开启一个事务都使用不同的ID的做法相反，同一个生产者实例在进行多个事务时应该使用相同的`TRANSACTIONAL_ID`。Kafka依靠这个ID来维护事务的上下文和状态。 `TRANSACTIONAL_ID`是与生产者实例绑定的，用来标识和管理该实例的事务状态。Kafka利用这个ID跨会话恢复生产者的事务状态，因此它是跨多个事务持久存在的，而不是每个事务都唯一。
2. **初始化事务：** 生产者必须调用`initTransactions()`方法来初始化事务支持。这一步会确保事务协调器和生产者之间的通信建立，为开始新事务做准备。
3. **开始事务：** 在发送任何消息之前，生产者通过调用`beginTransaction()`方法来标记一个新事务的开始。从这一刻起，所有发送的消息都属于这个事务的一部分。
4. **发送消息：** 在事务中，可以使用常规的`send()`方法来发送消息。这些消息不会立即对消费者可见，而是处于“未解决”状态，等待事务的提交或中止。
5. **提交或中止事务：** 根据业务逻辑的成功或失败，可以选择调用`commitTransaction()`或`abortTransaction()`来提交或中止当前事务。
   1. **提交事务（`commitTransaction()`）：** 如果所有操作都成功执行，生产者调用此方法来提交事务。这会使事务中的所有消息对消费者可见。
   2. **中止事务（`abortTransaction()`）：** 如果业务逻辑失败，生产者调用此方法来中止事务。这会回滚事务中的所有操作，已发送的消息对消费者保持不可见。

RocketMQ 的事务消息
RocketMQ 支持的事务满足的是`生产消息`和`本地事务`相结合的一种事务形态。旨在处理分布式系统中的跨服务事务。RocketMQ的事务消息能够确保在分布式系统的不同组件间保持数据的一致性和完整性，特别是在涉及到多个步骤或操作必须作为一个整体完成的场景中。
[官方文档给出的应用场景](https://rocketmq.apache.org/zh/docs/featureBehavior/04transactionmessage/)

### RocketMQ事务消息工作机制
RocketMQ实现事务消息的方式略有不同于Kafka。它主要通过以下三个步骤来管理事务：

1. **半消息（Half Message）**：当发送事务消息时，消息首先被标记为“半消息”（Half Message），这意味着这个消息不会立即对消费者可见。半消息是事务操作开始的标志。
2. **本地事务执行**：发送半消息后，生产者将执行本地事务（如数据库操作）。这是一个关键步骤，因为它决定了事务消息是否应该被提交或回滚。
3. **消息提交或回滚**：根据本地事务的执行结果，生产者将决定是提交还是回滚消息：
   - 如果本地事务成功，生产者将通知RocketMQ提交半消息，使其对消费者可见。
   - 如果本地事务失败，生产者将通知RocketMQ回滚半消息，这样它就不会被消费。
### 事务状态检查
RocketMQ提供了一个事务状态回查的机制。如果由于网络问题或应用崩溃等原因，RocketMQ无法从生产者那里接收到事务提交或回滚的指令，它将主动询问生产者该事务消息的最终状态（提交还是回滚）。生产者需要实现一个接口来提供这种状态检查的逻辑。

### 解决的场景
RocketMQ的事务消息特别适合处理那些需要确保跨多个系统或服务操作都成功完成才算成功的场景。典型的应用场景包括：

- **分布式事务**：在微服务架构中，一个业务流程可能跨越多个服务，涉及多个数据库操作。使用事务消息可以确保这些不同服务中的操作要么全部成功，要么全部失败。
- **可靠消息最终一致性**：在电商订单处理、金融交易等需要高一致性的场景中，事务消息保证了业务流程的不同步骤可以最终达到一致状态。
- **复杂业务逻辑的处理**：例如，在一个订单系统中，用户下单操作可能需要同时更新库存、记录订单信息、发送支付请求等。事务消息确保了这些操作要么全部成功执行，要么在遇到任何失败时都能回滚到操作前的状态。


通过这种方式，RocketMQ的事务消息提供了一种强大的机制，支持在分布式系统中进行复杂的业务操作，同时确保数据的一致性和完整性。

业务操作+消息发送的事务解决方案
由于本身Spring 的事务机制只保证数据库操作的原子性，所以当需要涉及数据库的业务操作和其他中间件操作如kafka 操作具有原子性的时候，就要用其他的方案来保证。

这两个操作的不同顺序 对应了两种典型的解决方案
## 本地事务+本地消息表
先业务操作， 再发送消息。

本地事务+本地消息表+普通消息队列， 将需要发送的消息作为数据库操作的一部分，保存到数据库中的一个表里，然后通过另外的进程或服务读取该表中的消息并发送到Kafka。这种方法确保了数据库操作和消息发送在==逻辑上的原子性==，因为它们都在同一个数据库事务中处理。消息的发送可以稍后异步进行，从而降低对实时性的要求。
这种方案通常包括以下几个步骤：

1. **本地事务执行**：首先在发起操作的服务中执行本地数据库事务。
2. **记录本地消息**：在本地事务中，将与操作相关的消息记录到一个本地消息表中。这个消息表作为事务的一部分，确保了消息记录操作的原子性。
3. **发布消息**：本地事务提交后，从本地消息表中读取消息，并将其发布到消息队列中。这个步骤通常由一个独立的后台进程或定时任务执行，以确保即使消息初次发送失败也能重试。
4. **消息消费**：其他服务从消息队列中订阅并消费消息，执行相应的业务逻辑。

### 劣势

- **开发维护成本**：开发者需要手动实现消息表的管理逻辑，包括记录消息、处理发送状态、实现失败重试等。
- **系统复杂度**：增加了系统的复杂度，需要更多的代码来保证消息的可靠发送和处理。
- **性能考量**：频繁地访问本地消息表可能对数据库性能产生影响，特别是在高并发场景下。
- **消息缺乏回滚能力**：如果消息最终发送失败（虽然可能性较小），业务操作实际已经commit, 无法rollback, 此时会造成数据的不一致 。且这种数据不一致要基于合理的告警机制或者对账机制才能发现， 发现数据不一致后还要有额外的数据修复逻辑

## RocketMQ   事务消息
[根据官方文档给出的应用场景](https://rocketmq.apache.org/zh/docs/featureBehavior/04transactionmessage/)

如前对RocketMQ事务消息的介绍，它先发送prepare  消息，在执行业务操作，然后根据业务操作结果决定消息是否真正发送， 这种处理逻辑相当于事务操作有了rollback 功能， 大大提高了数据的最终一致性
### RocketMQ事务消息的优势

- **简化开发**：RocketMQ的事务消息机制内置了事务的状态管理和回查机制，大大减少了开发者需要手动实现的逻辑。
- **降低系统复杂度**：使用RocketMQ的事务消息，开发者可以专注于业务逻辑本身，而不是事务的具体实现细节。
- **提高可靠性**：RocketMQ设计用于高并发场景，提供了高可用和高性能的消息服务，确保了消息的可靠传递。

总的来说，虽然本地事务加本地消息表的方案在某些情况下是可行的，但它确实增加了系统的复杂度和开发维护成本。使用支持事务消息的消息队列（如RocketMQ）可以提供一种更为高效、可靠的解决方案，减轻开发者的负担，提升系统的整体稳定性和可维护性。

# 如何用Kafka 实现消息回查机制保证消息的可靠性投递
kafka 是一个常用消息中间件，但是它并不支持本文重点讨论的业务操作+消息发送的事务消息，因此接下来探讨如何用如何用Kafka 实现消息回查机制保证消息的可靠性投递。

实现思路参考RocketMQ的两阶段提交和消息回查， 具体实现不参与kafka 源码，而是以消息中间件的形式借由消息转发操作完成。

总体的实现逻辑上， 生产者发送了一条事务消息， 中间件拿到这条消息后，消费转存至MySQL, 中间件等到消息确认 or 取消结果，或者在一段时间后对消息进行回查，如果消息确认中间件将消息转发至真正的业务Topic 


## 1. 消息中间件如何识别事务消息并消费

如何识别一条消息是事务消息，有以下几种消息
1.  Topic命名约定
    一种简单的方法是通过Topic命名来区分。例如，所有需要支持回查的Topic可以遵循一个特定的命名模式，如添加前缀或后缀（例如，`replayable-myTopic`）。这种方法的优点是简单易实施，但缺点是灵活性较低，且对现有系统可能需要更多的改动。
2. 特定主题或分区
   将需要回查的消息发送到Kafka的特定主题或分区中。这样，中间件只需监听这个特定的主题或分区来处理需要回查的消息。这种方法要求生产者在发送消息时知道哪些消息需要回查，并据此发送到正确的主题或分区。
3. Topic配置属性
   Kafka允许为每个Topic设置自定义配置属性。可以引入一个自定义属性（如`replayable=true`）来标识一个Topic需要支持消息回查。这种方式比命名约定更为灵活和隐蔽，但要求应用层和消息生产者遵循这一约定，并且需要在应用层实现逻辑来处理这些属性。
4. 消息元数据标记
   在消息发送时，可以在消息的元数据（Metadata）中添加特定的标记或字段来指示这条消息需要进行回查。这些元数据字段可以是：

设计考虑：
- **性能**：确定这些方法中哪一种对生产和消费的性能影响最小。
- **易用性**：选择易于实施和维护的方法。
- **灵活性**：评估是否需要对单个消息进行标记，还是以Topic为单位进行区分。

我这里首先考虑以topic 维度对事务消息进行管理，且从易于实现的角度考虑选择特定topic的方式实现。

## 2. 如何识别消息类型、转发信息、回查信息
#### 使用Kafka消息头
**优点**：
- 保持了消息体的纯净和独立性。
- 灵活性高，易于添加或修改额外的控制信息和元数据。
- 性能考虑，对于小到中等大小的消息，使用消息头的性能开销相对较小
  **缺点**：
- 新版本依赖：较旧版本的Kafka客户端可能不支持消息头功能，这要求生产者和消费者使用支持消息头的Kafka版本。
- **额外处理**：消费者需要额外的步骤来读取和解析消息头。

#### 预先定义消息格式
**优点**：
- 直接且简单，易于实现。
- 不依赖Kafka特定的功能，具有较好的兼容性。
  **缺点**：
- 增加了消息体的大小。
- 需要在消费端进行消息解析，略微增加了处理的复杂性。

消息类型包括 prepare、commit、rollback
转发信息,需要转发至的真正业务tpoic、 如果需要指定分区的话还包括key信息
回查信息，包括回查方式如HTTP、RPC, 回查地址，回查接口等

考虑到需要的所有消息较多， 我决定采用预定义消息的方案。


## 3. 回查功能的实现
消息的唯一标识，每一条业务发送的消息都应该有一个唯一标识供回查使用

可以可以支持HTTP 和RPC（如Dubbo, Thrift） 两种形式.
对于HTTP 接口， 回查实现比较简单
对于RPC 接口， 要根据具体的协议实现泛化调用。

## 4. 消息回查重试策略

在定时任务中对于消息生产者在一定时间内没有commit 或者rollback 的信息，消息中间件需要主动回查， 主要考虑两个方面，
1. **首次回查延迟**：在发送事务消息后，如果消息的状态仍然是`PREPARED`（即未决定是提交还是回滚），Broker将在首次发送消息的一定时间后（默认约1分钟）尝试对该消息进行首次回查。
2. **回查间隔和次数**：如果首次回查后，事务状态仍未确定，消息中间件将继续按照一定的时间间隔进行后续的回查。这个间隔时间会逐渐增加，直到达到最大回查次数（默认是15次）。这个增加的策略是可以是指数级增长的，旨在减少对系统资源的占用。

如果消息达到最大回查次数后仍然不能确定事务状态），默认行为将这条事务消息标记为回滚（ROLLBACK）。这意味着，即便实际的本地事务可能已经提交，消息中间件也不会再尝试投递这条消息给消费者。这样做可以避免不确定性对消息的影响。但这也要求开发者关注这一机制可能带来的影响，通过日志记录、监控、人工干预和业务补偿等措施，确保业务的健壮性和最终一致性。此外，优化事务消息的设计和使用也是减少这类问题发生的有效方法。

1. **日志记录和监控**：首先，应该确保这类事件能够被记录和监控到。这包括配置适当的日志记录在事务状态回查的实现中，以及设置监控告警当这种情况发生时能够及时通知到相关人员。
2. **人工干预**：进行人工干预，判断事务的实际状态，并采取相应的措施，如手动提交或回滚消息。
3. **业务补偿机制**：在业务设计时，可以考虑引入业务补偿机制。对于事务处理可能存在不确定性的业务场景，设计可回溯和补偿的业务流程，以便在事务消息处理失败或状态不确定时，可以通过业务层面的补偿操作来确保业务的最终一致性。
4. **优化事务消息设计**：如果这类问题频繁发生，可能需要回顾和优化事务消息的使用设计，检查是否存在事务消息使用不当或本地事务执行时间过长等问题。优化事务消息的设计和处理逻辑，减少事务状态不确定的情况。

## 5. 消息存储
MySQL
分区表或者分库分表

## 6.性能提升措施
批量操作, 回查是考虑支持批量操作
线程池，回查拿到结果的消息可以放到线程池异步执行
guava cache， 回查接口可以用guava cache 管理